<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[入门Webpack，看这篇就够了]]></title>
      <url>%2F2017%2F04%2F11%2FWebpack%E5%85%A5%E9%97%A8%E5%8F%AA%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
      <content type="text"><![CDATA[入门Webpack，看这篇就够了写在前面的话 阅读本文之前，先看下面这个webpack的配置文件，如果每一项你都懂，那本文能带给你的收获也许就比较有限，你可以快速浏览或直接跳过；如果你和十天前的我一样，对很多选项存在着疑惑，那花一段时间慢慢阅读本文，你的疑惑一定一个一个都会消失；如果你以前没怎么接触过Webpack，而你又你对webpack感兴趣，那么动手跟着本文中那个贯穿始终的例子写一次，写完以后你会发现你已明明白白的走进了Webpack的大门。 123456789101112131415161718192021222324252627282930313233343536373839404142//一个常见的Webpack配置文件var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123;entry: __dirname + "/app/main.js",output: &#123;path: __dirname + "/build",filename: "[name]-[hash].js"&#125;,module: &#123;loaders: [&#123;test: /\.json$/,loader: "json"&#125;,&#123;test: /\.js$/,exclude: /node_modules/,loader: 'babel'&#125;,&#123;test: /\.css$/,loader: ExtractTextPlugin.extract('style', 'css?modules!postcss')&#125;]&#125;,postcss: [require('autoprefixer')],plugins: [new HtmlWebpackPlugin(&#123;template: __dirname + "/app/index.tmpl.html"&#125;),new webpack.optimize.OccurenceOrderPlugin(),new webpack.optimize.UglifyJsPlugin(),new ExtractTextPlugin("[name]-[hash].css")]&#125; 什么是WebPack，为什么要使用它？为什要使用WebPack现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法模块化，让我们可以把复杂的程序细化为小的文件;类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；Scss，less等CSS预处理器…这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。 什么是WebpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 WebPack和Grunt以及Gulp相比有什么特性其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。 Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。 如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。 开始使用Webpack初步了解了Webpack工作方式后，我们一步步的开始学习使用Webpack。 安装Webpack可以使用npm安装，新建一个空的练习文件夹（此处命名为webpack sample progect），在终端中转到该文件夹后执行下述指令就可以完成安装。 1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack 正式使用Webpack前的准备在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件npm init 输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。 package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包 12// 安装Webpacknpm install --save-dev webpack 回到之前的空文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中，此时项目结构如下图所示 index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js只包括一个用来返回包含问候信息的html元素的函数。 123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement('div'); greet.textContent = "Hi there and greetings!"; return greet;&#125;; main.js用来把Greeter模块返回的节点插入页面。 123//main.js var greeter = require('./Greeter.js');document.getElementById('root').appendChild(greeter()); 正式使用Webpackwebpack可以在终端中使用，其最基础的命令是 1webpack &#123;entry file/入口文件&#125; &#123;destination for bundled file/存放bundle.js的地方&#125; 只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果你的webpack没有进行全局安装，那么当你在终端中使用此命令时，需要额外指定其在node_modules中的地址，继续上面的例子，在终端中属于如下命令 12//webpack非全局安装的情况node_modules/.bin/webpack app/main.js public/bundle.js 结果如下 可以看出webpack同时编译了main.js 和Greeter,js,现在打开index.html,可以看到如下结果 有没有很激动，已经成功的使用Webpack打包了一个文件了。不过如果在终端中进行复杂的操作，还是不太方便且容易出错的，接下来看看Webpack的另一种使用方法。 通过配置文件来使用WebpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。 还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。 1234567module.exports = &#123; entry: __dirname + "/app/main.js",//已多次提及的唯一入口文件 output: &#123; path: __dirname + "/public",//打包后的文件存放的地方 filename: "bundle.js"//打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。现在如果你需要打包文件只需要在终端里你运行webpack(非全局安装需使用node_modules/.bin/webpack)命令就可以了，这条命令会自动参考webpack.config.js文件中的配置选项打包你的项目，输出结果如下 又学会了一种使用Webpack的方法，而且不用管那烦人的命令行参数了，有没有感觉很爽。有没有想过如果可以连webpack(非全局安装需使用node_modules/.bin/webpack)这条命令都可以不用，那种感觉会不会更爽~，继续看下文。 更快捷的执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下。 12345678910111213&#123; "name": "webpack-sample-project", "version": "1.0.0", "description": "Sample webpack project", "scripts": &#123; "start": "webpack" //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, "author": "zhang", "license": "ISC", "devDependencies": &#123; "webpack": "^1.12.9" &#125;&#125; 注：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。npm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，以下是执行npm start后命令行的输出显示 现在只需要使用npm start就可以打包文件了，有没有觉得webpack也不过如此嘛，不过不要太小瞧Webpack，其强大的功能包含在其一系列可供配置的选项中，我们一项项来看。 Webpack的强大功能##生成Source Maps（使调试更容易）开发总是离不开调试，如果可以更加方便的调试当然就能提高开发效率，不过打包后的文件有时候你是不容易找到出错了的地方对应的源代码的位置的，Source Maps就是来帮我们解决这个问题的。通过简单的配置后，Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。 在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下：devtool选项 配置结果source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； 正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。在学习阶段以及在小到中性的项目上，eval-source-map是一个很好的选项，不过记得只在开发阶段使用它，继续上面的例子，进行如下配置 12345678module.exports = &#123; devtool: 'eval-source-map',//配置生成Source Maps，选择合适的选项 entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/public", filename: "bundle.js" &#125;&#125; cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本是使用。 使用webpack构建本地服务器想不想让你的浏览器监测你的代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖npm install –save-dev webpack-dev-serverdevserver作为webpack配置选项中的一项，具有以下配置选项devserver配置选项 功能描述contentBase 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）port 设置默认监听端口，如果省略，默认为”8080“inline 设置为true，当源文件改变时会自动刷新页面colors 设置为true，使终端输出的文件为彩色的historyApiFallback 在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html 继续把这些命令加到webpack的配置文件中，现在的配置文件如下所示 12345678910111213141516module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/public", filename: "bundle.js" &#125;, devServer: &#123; contentBase: "./public",//本地服务器所加载的页面所在的目录 colors: true,//终端中输出结果为彩色 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125; &#125; Loaders鼎鼎大名的Loaders登场了！Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面：test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）loader：loader的名称（必须）include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；query：为loaders提供额外的设置选项（可选） 继续上面的例子，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，配置方法如下//安装可以装换JSON的loadernpm install –save-dev json-loader 12345678910111213141516171819202122232425module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/public", filename: "bundle.js" &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: "json" &#125; ] &#125;, devServer: &#123; contentBase: "./public", colors: true, historyApiFallback: true, inline: true &#125;&#125; 创建带有问候信息的JSON文件(命名为config.json) 1234//config.json&#123; "greetText": "Hi there and greetings from JSON!"&#125; 更新后的Greeter.js 1234567var config = require('./config.json');module.exports = function() &#123; var greet = document.createElement('div'); greet.textContent = config.greetText; return greet;&#125;; Loaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。 BabelBabel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的： 下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持；使用基于JavaScript进行了拓展的语言，比如React的JSX Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先来一次性安装这些依赖包// npm一次性安装多个依赖模块，模块之间用空格隔开npm install –save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在webpack中配置Babel的方法如下 123456789101112131415161718192021222324252627282930313233module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/public", filename: "bundle.js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel',//在webpack的module部分的loaders里进行配置即可 query: &#123; presets: ['es2015','react'] &#125; &#125; ] &#125;, devServer: &#123; contentBase: "./public", colors: true, historyApiFallback: true, inline: true &#125;&#125; 现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOMnpm install –save react react-dom 使用ES6的语法，更新Greeter.js并返回一个React组件 123456789101112131415//Greeter,jsimport React, &#123;Component&#125; from 'react'import config from './config.json';class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 使用ES6的模块定义和渲染Greeter模块 123456//main.jsimport React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';render(&lt;Greeter /&gt;, document.getElementById('root')); Babel的配置选项Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下： 1234567891011121314151617181920212223242526// webpack.config.jsmodule.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/public", filename: "bundle.js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125; ] &#125;, devServer: &#123;...&#125; // Omitted for brevity&#125; 12345//.babelrc&#123; "presets": ["react", "es2015"]&#125; 到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。 一切皆模块Webpack有一个不可不说的优点，它把所有的文件都可以当做模块处理，包括你的JavaScript代码，也包括CSS和fonts以及图片等等等，只有通过合适的loaders，它们都可以被当做模块被处理。 CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 继续上面的例子//安装npm install –save-dev style-loader css-loader 123456789101112131415161718192021222324252627282930//使用module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "bundle.js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: 'style!css'//添加对样式表的处理 &#125; ] &#125;, devServer: &#123;...&#125;&#125; 注：感叹号的作用在于使同一文件能够使用不同类型的loader 接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式 12345678910111213141516171819html &#123; box-sizing: border-box; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;body &#123; margin: 0; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;&#125;h1, h2, h3, h4, h5, h6, p, ul &#123; margin: 0; padding: 0;&#125; 你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下 12345678//main.jsimport React from 'react';import &#123;render&#125; from 'react-dom';import Greeter from './Greeter';import './main.css';//使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById('root')); 通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。不过这也只是webpack把css当做模块而已，咱们继续看看一个真的CSS模块的实践。 CSS module在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，且基于优化工具，依赖管理和加载管理可以自动完成。不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧是巨大且充满了全局类名，这使得维护和修改都非常困难和复杂。 最近有一个叫做 CSS modules 的技术就意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules“传递都所需要的地方，然后就可以直接把CSS的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。具体的代码如下 1234567891011121314151617181920212223242526module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123;...&#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: 'style!css?modules'//跟前面相比就在后面加上了?modules &#125; ] &#125;, devServer: &#123;...&#125;&#125; 创建一个Greeter.css文件 123456.root &#123; background-color: #eee; padding: 10px; border: 3px solid #ccc;&#125; 导入.root到Greeter.js中 123456789101112131415import React, &#123;Component&#125; from 'react';import config from './config.json';import styles from './Greeter.css';//导入class Greeter extends Component&#123; render() &#123; return ( &lt;div className=&#123;styles.root&#125;&gt;//添加类名 &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 放心使用把，相同的类名也不会造成不同组件之间的污染。CSS modules 也是一个很大的主题，有兴趣的话可以去官方文档查看更多消息 CSS预处理器Sass 和 Less之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句，你现在可能都已经熟悉了，在webpack里使用相关loaders进行配置就可以使用了，以下是常用的CSS 处理loadersLess LoaderSass LoaderStylus Loader不过其实也存在一个CSS的处理平台-PostCSS，它可以帮助你的CSS实现更多的功能，在其CSS官方文档可了解更多相关知识。 举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。 首先安装postcss-loader 和 autoprefixer（自动添加前缀的插件）npm install –save-dev postcss-loader autoprefixer 接下来，在webpack配置文件中进行设置，只需要新建一个postcss关键字，并在里面申明依赖的插件，如下，现在你写的css会自动根据Can i use里的数据添加不同前缀了。 123456789101112131415161718192021222324252627282930//webpack配置文件module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123;...&#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: 'style!css?modules!postcss' &#125; ] &#125;, postcss: [ require('autoprefixer')//调用autoprefixer插件 ], devServer: &#123;...&#125;&#125; 到现在，本文已经涉及到处理JS的Babel和处理CSS的PostCSS，它们其实也是两个单独的平台，配合Webpack可以很好的发挥它们的作用。接下来介绍Webpack中另一个非常重要的功能-Plugins 插件（Plugins）插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。 Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。 使用插件的方法要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续看例子，我们添加了一个实现版权声明的插件。 1234567891011121314151617181920212223242526//webpack.config.jsvar webpack = require('webpack');module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123;...&#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: 'style!css?modules!postcss' &#125;//这里添加PostCSS ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new webpack.BannerPlugin("Copyright Flying Unicorns inc.")//在这个数组中new一个就可以了 ], devServer: &#123;...&#125;&#125; 通过这个插件，打包后的JS文件显示如下 知道Webpack中的插件如何使用了，下面给大家推荐几个常用的插件 HtmlWebpackPlugin这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。 安装npm install –save-dev html-webpack-plugin 这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些改变：移除public文件夹，利用此插件，HTML5文件会自动生成，此外CSS已经通过前面的操作打包到JS中了，public文件夹里。在app目录下，创建一个Html文件模板，这个模板包含title等其它你需要的元素，在编译过程中，本插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，在本例中我们命名模板文件名称为index.tmpl.html，模板源代码如下 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.更新webpack的配置文件，方法同上,新建一个build文件夹用来存放最终的输出文件 1234567891011121314151617181920212223242526272829303132333435var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "bundle.js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: 'style!css?modules!postcss' &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html"//new 一个这个插件的实例，并传入相关的参数 &#125;) ], devServer: &#123; colors: true, historyApiFallback: true, inline: true &#125;&#125; Hot Module ReplacementHot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。在webpack中实现HMR也很简单，只需要做两项配置在webpack配置文件中添加HMR插件；在Webpack Dev Server中添加“hot”参数； 不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。 整理下我们的思路，具体实现方法如下Babel和webpack是独立的工具二者可以一起工作二者都可以通过插件拓展功能HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作； 更新我们的例子来实际看看如何配置 12345678910111213141516171819202122232425262728293031323334353637//webpack中的配置var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "bundle.js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: 'style!css?modules!postcss' &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html" &#125;), new webpack.HotModuleReplacementPlugin()//热加载插件 ], devServer: &#123; colors: true, historyApiFallback: true, inline: true, hot: true &#125;&#125; 安装react-transform-hmrnpm install –save-dev babel-plugin-react-transform react-transform-hmr 配置Babel 12345678910111213141516&#123; "presets": ["react", "es2015"], "env": &#123; "development": &#123; "plugins": [["react-transform", &#123; "transforms": [&#123; "transform": "react-transform-hmr", "imports": ["react"], "locals": ["module"] &#125;] &#125;]] &#125; &#125;&#125; 现在当你使用React时，可以热加载模块了 产品阶段的构建目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。 对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个“webpack.production.config.js”的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下 123456789101112131415161718192021222324252627282930313233343536373839var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "bundle.js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: 'style!css?modules!postcss' &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html" &#125;), ],&#125; …. 1234567891011121314//package.json&#123; "name": "webpack-sample-project", "version": "1.0.0", "description": "Sample webpack project", "scripts": &#123; "start": "webpack-dev-server --progress", "build": "NODE_ENV=production webpack --config ./webpack.production.config.js --progress" &#125;, "author": "Cássio Zen", "license": "ISC", "devDependencies": &#123;...&#125;, "dependencies": &#123;...&#125;&#125; 优化插件webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能 OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的IDUglifyJsPlugin：压缩JS代码；ExtractTextPlugin：分离CSS和JS文件 我们继续用例子来看看如何添加它们，OccurenceOrder 和 UglifyJS plugins 都是内置插件，你需要做的只是安装它们npm install –save-dev extract-text-webpack-plugin 在配置文件的plugins后引用它们 1234567891011121314151617181920212223242526272829303132333435363738394041var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "bundle.js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: ExtractTextPlugin.extract('style', 'css?modules!postcss') &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html" &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin("style.css") ]&#125; 缓存缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变） webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前 1234567891011121314151617181920212223242526272829303132333435363738394041var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/build", filename: "[name]-[hash].js" &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: "json" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: 'babel' &#125;, &#123; test: /\.css$/, loader: ExtractTextPlugin.extract('style', 'css?modules!postcss') &#125; ] &#125;, postcss: [ require('autoprefixer') ], plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html" &#125;), new webpack.optimize.OccurenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin("[name]-[hash].css") ]&#125; 现在用户会有合理的缓存了。 总结这是一篇好长的文章，谢谢你的耐心，能仔细看到了这里，大概半个月前我第一次自己一步步配置项目所需的Webpack后就一直想写一篇笔记做总结，几次动笔都不能让自己满意，总觉得写不清楚。直到看到本文的英文版Webpack for React，真的有多次豁然开朗的感觉，喜欢看原文的点链接就可以看了。其实关于Webpack本文讲述得仍不完全，不过相信你看完后已经进入Webpack的大门，能够更好的探索其它的关于Webpack的知识了。 欢迎大家在文后发表自己的观点讨论。 小结上述的过程是webpack1的，会有部分错误，我在练习的时候一步一步的改过来，当然还有一部分没有实施。下面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var webpack = require('webpack')var HtmlWebpackPlugin = require('html-webpack-plugin')var ExtractTextPlugin = require('extract-text-webpack-plugin')module.exports = &#123; devtool: 'eval-source-map', //找到出错了的地方对应的源代码的位置 entry: __dirname + "/app/main.js", //唯一的入口文件 output: &#123; path: __dirname + "/build", //打包后文件存放的路径 filename: "[name]-[hash].js", //打包后输出文件的文件名 &#125;, module: &#123; //在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: "json-loader" &#125;, &#123; test: /\.js$/, exclude: /node_modules/, //在webpack的module部分的loaders里进行配置即可 loader: "babel-loader" &#125;, &#123; test: /\.css$/, exclude: /node_modules/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: [ &#123;loader:"css-loader",options: &#123;sourceMap: true, importLoaders: 1&#125;&#125;, &#123;loader: 'postcss-loader', options: &#123;sourceMap: 'inline'&#125;&#125;, ] &#125;) &#125; ] &#125;, plugins: [ new webpack.LoaderOptionsPlugin(&#123; options: &#123; devServer: &#123; contentBase: "./public", //本地服务器所加载的页面所在的目录 colors: true, historyApiFallback: true, //不跳转 inline: true //实时刷新 &#125; &#125; &#125;), new webpack.BannerPlugin("Copyright Flying Unicorns inc."), new HtmlWebpackPlugin(&#123; template: __dirname + "/app/index.tmpl.html" //new 一个这个插件的实例，并传入相关的参数 &#125;), new ExtractTextPlugin("[name]-[hash].css") ]&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用阿里云的免费SSL证书让网站从http换成https]]></title>
      <url>%2F2017%2F04%2F06%2F%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6%E8%AE%A9%E7%BD%91%E7%AB%99%E4%BB%8Ehttp%E6%8D%A2%E6%88%90https%2F</url>
      <content type="text"><![CDATA[HTTP 协议是不加密传输数据的，也就是用户跟你的网站之间传递数据有可能在途中被截获，破解传递的真实内容，所以使用不加密的 HTTP 的网站是不太安全的。所以， Google 的 Chrome 浏览器将在 2017 年 1 月开始，标记使用不加密的 HTTP 协议的网站为 Not Secure，不安全。 现在你要做的就是让网站支持 HTTPS，并不难，而且现在可以免费做到。要使用 HTTPS，你需要安全机构颁发的安全证书，然后配置服务器，去使用这个证书。下面介绍一下在阿里云免费申请安全证书，还有配置一般的 NGINX 服务器支持 HTTPS 的方法。 申请证书 1、登录：阿里云控制台，产品与服务，证书服务，购买证书。 2、购买：证书类型选择 免费型DV SSL，然后完成购买。 补全：在 我的证书 控制台，找到购买的证书，在操作栏里选择 补全。填写证书相关信息。 3、域名验证：可以选择 DNS，如果域名用了阿里云的 DNS 服务，再勾选一下 证书绑定的域名在 阿里云的云解析。 4、上传：系统生成 CSR，点一下 创建。 5、提交审核。 如果一切正常，10 分钟左右，申请的证书就会审核通过。 申请证书要注意的是验证域名，就是你要验证你想绑定证书的域名是你自己的，如果选择使用 DNS 验证，你需要在域名的管理里，添加一条特定的 DNS 记录，这样就可以证名这个域名是你自己的。使用了阿里云的云解析服务，这个步骤可以自动完成，会自动为你添加一条 DNS 验证的记录。 输入证书要绑定的域名： 填写个人信息： 在域名的管理里，因为我用了阿里云的 DNS 解析服务，所以会自动添加一条 CNAME 记录，这条记录就是验证域名所有权用的： 下载证书在阿里云的证书管理那里，如果申请的证书审核通过，你就可以下载了，点击 下载，可以选择不同的类型，可以选择 NGINX，或 Apache 之类的服务器。根据自己网站的 Web 服务器类型，下载对应的证书。解压以后，你会得到两个文件一个是 .key，一个是 .pem。 配置 NGINX 的 HTTPS有了证书，就可以去配置 Web 服务器去使用这个证书了，不同的 Web 服务器地配置方法都不太一样。下面用 NGINX 服务器作为演示。我的域名是 ninghao.org，出现这个文字的地方你可以根据自己的实际情况去替换一下。 下载并上传证书创建一个存储证书的目录： 1sudo mkdir -p /etc/nginx/ssl/ninghao.org 把申请并下载下来的证书，上传到上面创建的目录的下面。我的证书的实际位置是： 123/etc/nginx/ssl/ninghao.org/213985317020706.pem/etc/nginx/ssl/ninghao.org/213985317020706.key NGINX 配置文件你的网站可以同时支持 HTTP 与 HTTPS，HTTP 默认的端口号是 80，HTTPS 的默认端口号是 443。也就是如果你的网站要使用 HTTPS，你需要配置网站服务器，让它监听 443 端口，就是用户使用 HTTPS 发出的请求。 下面是一个基本的监听 443 端口，使用了 SSL 证书的 NGINX 配置文件，创建一个配置文件： 1touch /etc/nginx/ssl.ninghao.org.conf 把下面的代码粘贴进去： 1234567891011121314server &#123; listen 443; server_name ninghao.org; ssl on; root /mnt/www/ninghao.org; index index.html; ssl_certificate /etc/nginx/ssl/ninghao.org/213985317020706.pem; ssl_certificate_key /etc/nginx/ssl/ninghao.org/213985317020706.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL; ssl_prefer_server_ciphers on;&#125; 上面的配置里，ssl_certificate 与 ssl_certificate_key 这两个指令指定使用了两个文件，就是你下载的证书，解压之后看到的那两个文件，一个是 .pem，一个是 .key。你要把这两个文件上传到服务器上的某个目录的下面。 重新加载 NGINX 服务： 1sudo service nginx reload 或: 1sudo systemctl reload nginx 验证配置在浏览器上输入带 https 的网站地址：https://ninghao.org 如果正确的配置了让服务器使用 SSL 证书，会在地址栏上显示一个绿色的小锁头图标。 点开那个小锁头，会显示安全连接，再打开 详细信息。 提示： This page is secure (valid HTTPS). 打开 View certificate，会显示证书的相关信息。 搜索引擎优化2015 年 5 月 25 日，百度发公告声明已全面支持 HTTPS 网页的收录，使用 HTTPS 的网页被认为更安全，所以在排名上会被优先。 百度还推荐使用 301 重定向，把网站的 HTTP 重定向到 HTTPS 。 前几天我让宁皓网支持 HTTPS，并观察了搜索量，并未受到影响。所以，至少不用担心换成 HTTPS 以后，搜索量会下降。不过百度的反应一般都比较慢，需要给他更长的时间。换成 HTTPS 的后两天，谷歌已经收录了 HTTPS 版本的首页，但是百度至今还没有反应。不管怎么样，使用 HTTPS 都是迟早要做的事情。 NGINX 配置使用 301 重定向： 123456server &#123; listen 80; server_name ninghao.org; return 301 https://$host$request_uri;&#125; 上面的配置会让对 HTTP 网页的请求，重定向到 HTTPS 版本的网页上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript正则表达式学习和总结]]></title>
      <url>%2F2017%2F03%2F23%2FJavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[新建正则表达式 方法一：直接量语法 12var reg=/pattern/attribute 创建RegExp对象的语法 1var reg =new RegExp(pattern,attributes); 参数说明： 参数 pattern 是一个字符串，指定了正则表达式的魔石或其他正则表达式 参数 attributes 是一个可选的字符串，包含属性 ‘g’、’i’和’m’，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则省略改参数。 两者的区别在于： 采用直接量语法新建的正则表达式对象在代码编辑时就会产生，是平常开发模式中常用的方式； 采用构造函数生成的正则对象要在代码运行时生成 正则表达式使用： 正则对象的方法是指这样使用的： RegExp对象.方法（字符串） 字符串对象的方法是这样使用： 字符串。方法（RegExp对象） 正则对象的属性和方法属性 gnoreCase 返回布尔值，表示RegExp对象是否具有标志 i global 返回布尔值，表示RegExp对象是否具有表示 g multiline 返回布尔值，表示RegExp对象是否具有表示 m lastIndex 一个整数，标识开始下一次匹配的字符位置 soure 返回正则表达式的原文本 （不包括反斜杠） i 执行对大小写不敏感的匹配 g 执行全局匹配 （查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配正则表达式作用 验证 由于验证时，通常需要在前后加上 ^ 和 $,以匹配整个待验证字符串； 搜索替换 搜索、替换时是否加上此限定规则更具有搜索的需求而定，此外，也有可能在前后加上 \b 而不是 ^ 和 $ 字符类匹配 […]查找方括号之间的任何字符 [^..]查找任何不在方括号之间的字符 [a-z]查找任何从小写a到小写z的字符 [A-Z]查找任何从大写A到大写Z的字符 [A-z]查找任何从大写A到小写z的字符 . 查找单个字符，除了换行和行结束符 \w 查找单词字符，等价于 [a-zA-Z0-9] \W 查找非单词字符，等价于 [^a-zA-Z0-9] \s 查找空白字符 \S 查找非空白字符 \d 查找数字，等价于[0-9] \D 查找非数字字符，等价于[^0-9] \b 匹配单词边界 \r 查找回车符 \t 查找制表符 \0 查找NULL字符 \n 查找换行符 重复字符匹配 {n,m}匹配前一项至少n次，但不能超过m次 {n,}匹配前一项n次或更多次 {n}匹配前一项n次 n?匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1} n+匹配前一项一次或多次，等价于{1,} n*匹配前一项0次或多次，等价于{0，} n$匹配任何结尾为n的字符串 ^n匹配任何开头为n的字符串 ？=n匹配任何其后紧接指定字符串n的字符串 ?!n匹配任何其后没有紧接指定字符串n的字符串 匹配特定数字 ^[1-9]\d*$ 匹配正整数 ^-[1-9]\d*$ 匹配负整数 ^-?[0-9]\d*$ 匹配整数 ^[1-9]\d*|0$ 匹配非负整数（正整数 + 0） ^-[1-9]\d*|0$ 匹配非正整数（负整数 + 0） ^[1-9]\d.\d|0.\d[1-9]\d$ 匹配正浮点数 ^-([1-9]\d.\d|0.\d[1-9]\d)$ 匹配负浮点数 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 匹配浮点数 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 匹配非正浮点数（负浮点数 + 0）#####匹配特定字符串 ^[A-Za-z]+$ 匹配由26个英文字母组成的字符串 ^[A-Z]+$ 匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ 匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ 匹配由数字和26个英文字母组成的字符串 ^\w+$ 匹配由数字、26个英文字母或者下划线组成的字符串 方法test方法 检索字符串中指定的值。返回true或者false 如果字符串string中含有与RegExpObject匹配的文本，则返回true，否则返回falsedemo1 如果正则表达式带有g修饰符，则每一次test方法都从上一次匹配结束的位置开始匹配。 使用了g修饰符的正则表达式，表示要记录每一次搜索的位置，直接使用test方法，每次开始搜索的位置都是上一次匹配的最后一个位置。 1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;test方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var reg = /abc/g; var str = "123abc456abc"; console.log(reg.lastIndex);//0 console.log(reg.test(str));//true console.log(reg.lastIndex);//6 console.log(reg.test(str));//true console.log(reg.lastIndex);//12 console.log(reg.test(str));//false &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; demo2 如果正则表达式使一个空字符串，则会匹配所有的字符串，但需要使用new RegExp()方式 123456789101112131415&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;test方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; console.log(new RegExp('').test('abc'));//true console.log(/''/.test('abc'));//false console.log(/''/.test("''"));//true &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; exec方法 exec() 方法用于检索字符串中的正则表达式的匹配 返回一个数组，其中存放匹配的结果。如果未找到，则返回值为null demo112345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;exec方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "xyz"; var reg1 = /x/; var reg2 = /a/; var res1 = reg1.exec(str); var res2 = reg2.exec(str); console.log(res1);//["x", index: 0, input: "xyz"] console.log(res2);//null &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Demo2 如果正则表达式包括圆括号，则返回的数组会包括多个元素。首先是整个匹配成功的结果，后面是圆括号匹配的结果，如果有多个圆括号，他们的匹配成功结果都会成为数组元素 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;exec方法2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = 'abcdabc'; var reg = /(a)b(c)/; var res = reg.exec(str); console.log(res);//["abc", "a", "c", index: 0, input: "abcdabc"] &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 对于调用exec方法返回的数组具有以下两个属性 input 整个原待匹配的字符串 index 整个魔石匹配成功的开始位置 支持正则表达式的String对象的方法search方法 search方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的字符串。 返回值： stringObject中第一个与regexp相匹配的子串的起始位置 注释： 如果没有找到任何匹配的子串，则返回 -1（和indexOf方法类似） search() 方法不执行全局匹配，它将忽略标志g。它同时忽略regexp 的 lastIndex属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 Demo1234567891011121314&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;search方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "abcdcef"; console.log(str.search(/c/g));//2 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; match 方法 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。改方法类似indexOf()和lastIndexOf()，凡是它返回指定的值，而不是字符串的位置。 字符串对象的match方法与正则对象的exec方法比较类似 但是如果正则表达式带有g修饰符，那么match方法与exec方法就有差别 可以看到match返回了所有成功匹配的结果，但是exec方法只返回了一个Demo 12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;match方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "abcd"; var reg1 = /a/; var reg2 = /x/; console.log(str.match(reg1));//["a", index: 0, input: "abcd"] console.log(str.match(reg2));//null var str = "abcdabc"; var reg = /a/g; console.log(str.match(reg));//["a", "a"] console.log(reg.exec(str));//["a", index: 0, input: "abcdabc"] &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; replace 方法 replace() 方法用于在字符串中用一些替换另一些字符，或者换一个与正则表达式匹配的子串 返回值：一个新的字符串，使用replacement替换regexp的第一次匹配或所有匹配之后得到的 字符串stringObject 的 replace() 方法执行的查找替换的操作。它将在stringObject中查找与regexp相匹配的子字符串，然后用replacement来替换这些子串。如果regexp具有全局标志g，那么replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;replace方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "xxx"; console.log(str.replace('x','y'));//yxx console.log(str.replace(/x/,'y'));//yxx console.log(str.replace(/x/g,'y'));//yyy &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; repalce方法中特殊字符替换 字符 替换文本 $1、$2、…、$99 与regexp中的第1到99个子表达式相匹配的文本 $&amp; 位于匹配子串左侧的文本 $` 位于匹配子串左侧的文本 $` 位于匹配子串右侧的文本 $$ 直接量符号 demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;replace中的特殊字符替换&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //用子表达式替换：$1和$2 //正则表达式中()就是一个子表达式，$1对应是第一个表达式的内容，即java，$2为script var str = "javascript"; console.log(str.replace(/(java)(script)/,'$2$1')); //输出：scriptjava //$&amp; 为正则表达式匹配的字符串 //正则表达式通过直接量java来匹配，匹配结果为java，则 $&amp;的值为java，然后用字符串$&amp;-来替换匹配的字符串 var str1 = "javascript"; console.log(str1.replace(/java/,'$&amp;-')); //输出：java-script var str2 = "javascript"; // $`为匹配子串ava的左侧文本，则为j console.log(str2.replace(/ava/,"$`")); //输出：jjscript // $'为匹配子串ava的右侧文本，则为script console.log(str2.replace(/ava/,"$'")); //输出：jscriptscript // $$为直接量符号，即插入一个$符号 console.log(str2.replace(/ava/,"$$"));//输出：j$script &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;replace的参数replacement是函数match为匹配整个字符串，即：xyz456789%$&amp;^a1 为第一个子表达式，([^\d]*),匹配0个或多个非数字的字符，即：xyza2 为第二个子表达式， (\d*),匹配0个或多个的数字，即：45678a3 为第三个子表达式， ([^\w]*),匹配0个或匹配任何非单词字符。等价于[^A-Za-z0-9_],即%$&amp;^index 为魔石匹配出现的位置，从第一个字符已经匹配成功，则位置为0string为字符串本身，即： xyz45678%$&amp;^ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;replace的参数replacement是函数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; function replacer(match, a1, a2, a3, index, string) &#123; return [a1, a2, a3].join(' ~ '); &#125; var str = 'xyz45678%$&amp;^'; var reg = /([^\d]*)(\d*)([^\w]*)/ var res = str.replace(reg, replacer); console.log(res);//xyz ~ 45678 ~ %$&amp;^ &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; * split方法 split（‘字符串的分割正则’，返回数组的最大成员数）；返回分割后各部分组成的数组 demo12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;split方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = 'a,b , c,d'; var res = str.split(",");//以逗号来分割字符串 console.log(res);//["a", "b ", " c", "d"]; var str1 = 'a,b , c,,d'; var res1 = str1.split(/,*/);//以0或多个逗号来分割字符串 console.log(res1);//["a", "b", " ", " ", "c", "d"]; var str2 = 'a, b,c, d'; var res2 = str2.split(/, */);//以0或对个逗号空格来分割字符串 console.log(res2);//["a", "b", "c", "d"]; var str3 = 'a, b,c, d'; var res3 = str3.split(/, */,2);//以0或对个逗号空格来分割字符串，同时限制返回数组中最多有两项 console.log(res3);//["a", "b"]; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以变换正则的匹配规则来分割字符串 下面真这个的匹配规则是以0或多个X来进行分割，如果加上括号则括号匹配的部分也就是分割规则也会成为数组成员返回 demo123456789101112131415161718&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;split方法2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "x@@xx@xx@@"; var res = str.split(/x*/);//以0或者对个x为分隔符 console.log(res);//["", "@", "@", "@", "@", "@"]; var res1 = str.split(/(x*)/);//如果加上括号则括号匹配的部分也就是分割规则也会作为数组成员返回 console.log(res1);//["", "x", "@", "", "@", "xx", "@", "xx", "@", "", "@"] &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 正则表达式的一些应用* 1、字符串中出现最多的字符 var re = /(\w)/1+/g; (\w) 外面的圆括号表示分组，\1表示重复第一分组的内容， \1+表示\w匹配到的字符重复n次，后面的g表示执行全部替换 str.replace的第二个参数是函数，参数a表示真个匹配到的字符串，b表示第一捕获分组也就是出现重复的单个字符，将啊。length与记录过的最多重复num比较，如果a.length更大，就将它赋值给num，用value记录重复字符b，这个函数返回的是替换文本，但这里没有返回值，也就是说替换为空，每次替换这个函数都被执行 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;字符串中出现次数最多的字符&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = 'mmmmmmmmaaammmmmmmmmbbbbsccc'; function most(str) &#123; var arr = str.split(''); str = arr.sort().join('');//将字符串按单个字符分割，然后排序组合，经过这一步，相同的字符就会排列到一起 var reg = /(\w)\1+/g; var num = 0; var value = ''; str.replace(reg, function (a,b) &#123; // console.log(a); if (num&lt;a.length) &#123; num = a.length; value = b; &#125; &#125;); return '出现次数最多的字符是' + value + '出现了' + num + '次'; &#125; console.log(most(str)); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 从url中提取子域名12345var url = "http://www.abc.com"; var reg = /[^.]+/;//匹配除了.之外的其他字符 var res = reg.exec(url)[0].substr(7); console.log(reg.exec(url));//["http://www", index: 0, input: "http://www.abc.com"] console.log(res);//www 常用的正则表达式 匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7} 匹配QQ号码：[1-9][0-9]{4,} 邮政编码：[1-9]\d5 身份证： /^(\d{14}|\d{17})(\d|[xX])$/ 匹配ip地址：\d+.\d+.\d+.\d+ 匹配账号是否合法（字母开头，允许5-16字节，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$表单验证时很实用 匹配中文字符： /[\u4E00-\u9FA5\uf900-ufasd]/ 匹配Email地址：/^([a-zA-Z_0-9-])+@([a-zA-Z_0-9-])+(.[a-zA-Z_0-9-])+$/ （邮箱由三部分组成：1、一个或多个字母数字下划线和杠+@+一个或多个字母数字下划线和杠+。+一个或多个字母数字下划线和杠） 匹配网址url： [a-zA-z]+://[^\s]* 判断字符串是不是由数字组成： /^\d*$/ 限制文本框只能输入数字和小数点（两位小数点）：/^\d*.?\d{0,2}$/（说明：开头有0个或多个数字，（?表示匹配前一项0次或多次）中间有0个或者1个小数点，小数点后面有0个或者最多2个数字） 用户名正则： /^[\u4e00-\u9FA5\uf900-ufa2d-\ufa2d\w]{4,16}$/ (匹配规则：只能是中文，英文，数字，下划线，4-16个字符；匹配中文规则：/[\u4E00-\u9FA5\uf900-\ufa2d]/ ， \w 是匹配英文，数字，下划线)+匹配英文地址：/^[a-zA-Z][.a-zA-Z\s,0-9]?[a-zA-Z]+ （/匹&gt; &gt; + 配规则：包含点，字母，逗号，数字，但是开头和结尾必须是字母；分析开头必须为字母可以这样写/[a-zA-Z]/）结尾必须是字母可以这样写：/[a-zA-Z]+/ 中间包含点，字母，空格，逗号，数字的正则：/[a-zA-Z\s,0-9]?/ 外面的*号是0个或者多个，后面的问号？代表可有可无，有就匹配，没有就不匹配 匹配价格： /^\d*(.\d{0,2})?$/ (匹配价格： 开头有0或者多个数字，中间可能有一个小数点，后面有可能有0-2位小数) 单词的首字母大写：/\b(\w)|\s(\w)/g 验证日期格式： /^\d{4}[-/]\d{1,2}[-/]\d{1,2}$/ (日起格式&gt; + 有两种yyyy-mm-dd或yyyy/mm/dd 分析：月份和天数可能有一位或两位) 断断续续敲了这么多，感觉还是晕晕的。（实际项目中，会用到的基本就是验证用户名手机号邮箱，获取地址栏地址参数…敲完开饭）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-Next底部powered&&logo栏更改以及注意事项]]></title>
      <url>%2F2017%2F03%2F23%2FHexo-Next%E5%BA%95%E9%83%A8powered-logo%E6%A0%8F%E6%9B%B4%E6%94%B9%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[Hexo-Next底部logo栏更改以及注意事项（附官方文档）研究了hexo，搭建博客很方便，主题，插件化功能非常强大。 本篇文章适合对象：各位用的是Next主题，那么适合看本篇文章，如果别的主题想找思路的适合看看练练手。想学习基础更改，优化，简单配置请看 点击官方文档。这里面有基础的教程以及第三方能用到的插件都有介绍，都是傻瓜式操作。 PS:做插件化的朋友，请注意，站内搜索swiftype只有老用户才免费，新用户只有14天之后收费，RMB玩家可以略过，其他小伙伴可以选择Local Search，本站右上角就是Local Search，精准度还可以没有swiftype准，用用再说。搭建LocalSearch 方法如下： 如果有其他好的插件和优化方法，我更新本片博文，当然大家有好点，好工具也希望邮件私信我，一同来分享，帮助大家打造富有个性化的博客。问题说明用Next主题搭建起来的博客，在底部会有一个特别烦人的官方logo 对于强迫症的我必须要改掉、改掉、改掉！查遍了所有文章都没有告诉，遂打算自己写一篇，有需要的可以看看。（含泪阅读了Next所有的源文件，最后不过是两句话能说明白。。却耗费我3,4个小时，让我多说一会废话凑凑字数吧，都是眼泪啊！） 成果展示 看起来至少比原来的好多了，更有个性化风格。 解决方案重点来啦。 1.首先，找到 \themes\next\layout_partials\下面的footer.swig文件，打开会发现，如下图的语句： 看到划框的地方了吗？ 第一个框 是下面侧栏的“日期❤ XXX”如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把…标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将..都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 2.接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\ 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）打开之后，如图： 看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 到此就可以pu上去了，等待2分钟就搞定了。有的时候可能有延迟。快去改掉那些不属于你的元素吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apply 和 call 的区别]]></title>
      <url>%2F2017%2F03%2F22%2Fapply%E5%92%8Ccall%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[apply 和 call 的区别ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。 apply( )apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。 12345678910var obj = &#123; name : &apos;linxin&apos;&#125;function func(firstName, lastName)&#123; console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);&#125;func.apply(obj, [&apos;A&apos;, &apos;B&apos;]); // A linxin B 可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。 call( )call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。 123456789var obj = &#123; name: 'linxin'&#125;function func(firstName, lastName) &#123; console.log(firstName + ' ' + this.name + ' ' + lastName);&#125;func.call(obj, 'C', 'D'); // C linxin D 对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。 对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。 apply 和 call 的用法1.改变 this 指向 123456789var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this.name);&#125;func.call(obj); // linxin 我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于 123function func() &#123; console.log(obj.name);&#125; 2.借用别的对象的方法先看例子 1234567891011var Person1 = function () &#123; this.name = 'linxin';&#125;var Person2 = function () &#123; this.getname = function () &#123; console.log(this.name); &#125; Person1.call(this);&#125;var person = new Person2();person.getname(); // linxin 从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。 3.调用函数apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数。 1234function func() &#123; console.log('linxin');&#125;func.call(); // linxin call 和 bind 的区别在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容。它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。它们之间的区别有以下两点。 1.bind 发返回值是函数 12345678910var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this.name);&#125;var func1 = func.bind(obj);func1(); // linxin bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。 2.参数的使用 123456789function func(a, b, c) &#123; console.log(a, b, c);&#125;var func1 = func.bind(null,'linxin');func('A', 'B', 'C'); // A B Cfunc1('A', 'B', 'C'); // linxin A Bfunc1('B', 'C'); // linxin B Cfunc.call(null, 'linxin'); // linxin undefined undefined call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。 在低版本浏览器没有 bind 方法，我们也可以自己实现一个。 12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex布局语法教程]]></title>
      <url>%2F2017%2F03%2F22%2FFlex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[网页布局（layout）是css的一个中带你应用 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ###三、容器的属性以下6个属性设置在容器上。 123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 12345678flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性123456orderflex-growflex-shrinkflex-basisflexalign-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[针对github权限导致hexo部署失败的解决方案]]></title>
      <url>%2F2017%2F03%2F21%2F%E9%92%88%E5%AF%B9github%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4hexo%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[针对github权限导致hexo部署失败的解决方案hexo deplay出错，没有反应 今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程 1.因为没有报错信息，所以直接在网上搜解决方案，集广大网友们的智慧，然后使用了npm install hexo-deployer-git –save，而后hexo deploy，但是没有解决问题，而且爆出警告： 12npm WARN optional Skipping failed optional dependency /chokidar/fsevents:npm WARN notsup Not compatible with your operating system or architecture: fsevents@1.0.15 2.更新npm npm install npm -g ，更新成功 3.继续npm install hexo-deployer-git –save，hexo deploy 还是不行： 12345678910111213141516INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...fatal: Not a git repository (or any of the parent directories): .gitFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: Not a git repository (or any of the parent directories): .gitat ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)……(E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Socket.&lt;anonymous&gt; (internal/child_process.js:319:11)at emitOne (events.js:77:13)at Socket.emit (events.js:169:7)at Pipe._onclose (net.js:477:12) 4、后来灵机一动，把.deploy_git文件夹手动删除了，重新hexo deploy了一次，成功！ 问题描述：如题，hexo最后一次部署是在8月份，然后就是秋招，一直没有在hexo博客上上传新博文，等回过头打算整理几篇博客上传，发现一直部署失败，通过搜索网上前辈们的经验，我决定重新使用hexo+github pages搭建博客（顺便更新版本了），然而······并没有什么卵用······ 错误依旧如下（这已经是重复设置SSH key后的错误版本啦，与一开始的错误描述略有不同，不过都是github权限问题）： 123456789101112131415161718192021222324252627282930313233343536373839Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.at ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at ChildProcess.cp.emit (E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)FATAL Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.Error: Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.at ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at ChildProcess.cp.emit (E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) 之前的错误，有网友们有建议将deploy处设置不要使用https，而是改为SSH，如下： 1repository: https://github.com/username/username.github.io.git 修改为 1repo：git@github.com:username/username.github.io.git 修改了很多遍，以各种姿势······然而还是没有什么卵用 当然错误不是重点，重点是怎样使我们的博客可以重新部署到github上~ 当部署失败的时候，请按照以下步骤进行：（当然，在此之前，你可以选择 hexo init）教程有很多，一搜就可以，懒癌症可以点击传送门，这是一个比较全的搭建配置教程。 (1)检查是否有SSH key登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接跳到第（3）步；如果没有，则继续。 (2)新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：1$ ssh-keygen -t rsa -C "邮箱名" 然后会出现： 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/dell/.ssh/id_rsa): 直接回车就可以。然后会出现： 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 注意：输入密码的时候没有*字样的，直接输入就好。然后会出现： 1234567891011121314Your identification has been saved in /c/Users/dell/.ssh/id_rsa.Your public key has been saved in /c/Users/dell/.ssh/id_rsa.pub.The key fingerprint is:65:69:······02:4b emailname@email.comThe key's randomart image is:+--[ RSA 2048]----+| || . o . || . o o = o || . o * = o || E o + o . || . o. . . || .. |+-----------------+ 至此，密钥已经成功生成。 (3)接下来在github上添加SSH key：① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/dell/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。 ② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。 ③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。 (4)测试设置是否成功：1$ ssh -T git@github.com 有可能会出现： 123The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 或者是 123The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 这种情况下，直接 yes 回车 然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）： 12Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. (5)设置用户信息：12$ git config --global user.name &quot;用户名&quot;$ git config --global user.email &quot;你希望的邮箱名&quot; (6)然后就可以部署你的博客到github啦~12$ hexo g$ hexo d (7)更多常见hexo命令，(传送门)[http://www.tuicool.com/articles/yUreInQ]补充1：过程中也遇到一些其他问题，比如Error: Bad file number，但是总的来说，按照上面的步骤就可以解决因为github权限问题hexo部署失败的问题（前提是你的配置文件的内容没有问题）。 补充2：windows系统不要使用它自己的命令窗口！！！使用git shell或者 git bash 等之类的一些工具。 欢迎评论交流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态加载javascript和css]]></title>
      <url>%2F2017%2F03%2F20%2FloadJsCssLater%2F</url>
      <content type="text"><![CDATA[动态加载javascript 和 css 动态加载javascript方法 1234567891011function loadScript(url) &#123; var script =document.createElement("script"); script.type="text/javascript"; script.src=url; document.body.appenfChild(script);&#125;;loadScript("javascript/lib/cookie.js"); 方法二： 123456789101112131415161718function loadScriptString(code)&#123; var script=document.createElement("script"); script.type="text/javascript"; try&#123; // firefox/safari/chrome/opera script.appendChild(document.createTextNode(code)); &#125;catch&#123; // IE早起的浏览器，需要使用script的text属性来指定javascript代码 script.text = code; &#125;; document.body.appendChild(script);&#125;;var text="function test()&#123;alert('test');&#125;";loadScriptString(text);test(); 动态加载css 方法一 12345678function loadStyles(url)&#123; var link = document.createElement(link); link.type="text/css"; link.rel="stylesheet"; link.href=url; document.getElementsByTagName("head")[0].appendChild(link);&#125;;loadStyles("css/secondindex.css"); 方法二 12345678910111213141516171819function loadStyleString(cssText)&#123; var style=document.creatElement("style"); style.type="text/css";try&#123; // firefox/safari/chrome/opera style/appendChild(document.createTextNode(cssText));&#125;catch&#123; // IE早起的浏览器，需要使用style元素的stylesheet属性的cssText属性 style.stylesheet.cssText = cssText;&#125;;document.getElementsByTagName("head")[0].appendChild(style);&#125;var css = "body&#123;color:blue;&#125;";loadStyleString(css);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript问题汇总]]></title>
      <url>%2F2017%2F03%2F20%2FJS-Issue%2F</url>
      <content type="text"><![CDATA[https 协议下安卓端默认不加载http协议请求 解决办法 https://segmentfault.com/q/1010000004727822 我的解决办法是（把图片的域名更整体更换成https） zepto touch（最新版） 在chrome 55会tap事件会触发两次zepto issue (github zepto issue double tap)[https://github.com/madrobby/zepto/issues/1249] 最后选择用 @MarvinXu 的方法移除所有pointer事件，成功解决，tap在chrome上触发两次的问题。 zepto 获取input checkbox 是否选中 获取不到 需要引入zepto的selector.js模块 【错误处理】:Uncaught SyntaxError: Invalid or unexpected token这个错误是因为，js代码中存在非英文标点符号（仔细检查下代码） 未完待续…..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
