<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[apply 和 call 的区别]]></title>
      <url>%2F2017%2F03%2F22%2Fapply%E5%92%8Ccall%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[apply 和 call 的区别ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。 apply( )apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。 12345678910var obj = &#123; name : &apos;linxin&apos;&#125;function func(firstName, lastName)&#123; console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);&#125;func.apply(obj, [&apos;A&apos;, &apos;B&apos;]); // A linxin B 可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。 call( )call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。 123456789var obj = &#123; name: 'linxin'&#125;function func(firstName, lastName) &#123; console.log(firstName + ' ' + this.name + ' ' + lastName);&#125;func.call(obj, 'C', 'D'); // C linxin D 对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。 对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。 apply 和 call 的用法1.改变 this 指向 123456789var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this.name);&#125;func.call(obj); // linxin 我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于 123function func() &#123; console.log(obj.name);&#125; 2.借用别的对象的方法先看例子 1234567891011var Person1 = function () &#123; this.name = 'linxin';&#125;var Person2 = function () &#123; this.getname = function () &#123; console.log(this.name); &#125; Person1.call(this);&#125;var person = new Person2();person.getname(); // linxin 从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。 3.调用函数apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数。 1234function func() &#123; console.log('linxin');&#125;func.call(); // linxin call 和 bind 的区别在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容。它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。它们之间的区别有以下两点。 1.bind 发返回值是函数 12345678910var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this.name);&#125;var func1 = func.bind(obj);func1(); // linxin bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。 2.参数的使用 123456789function func(a, b, c) &#123; console.log(a, b, c);&#125;var func1 = func.bind(null,'linxin');func('A', 'B', 'C'); // A B Cfunc1('A', 'B', 'C'); // linxin A Bfunc1('B', 'C'); // linxin B Cfunc.call(null, 'linxin'); // linxin undefined undefined call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。 在低版本浏览器没有 bind 方法，我们也可以自己实现一个。 12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex布局语法教程]]></title>
      <url>%2F2017%2F03%2F22%2FFlex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[网页布局（layout）是css的一个中带你应用 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ###三、容器的属性以下6个属性设置在容器上。 123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 12345678flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性123456orderflex-growflex-shrinkflex-basisflexalign-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[针对github权限导致hexo部署失败的解决方案]]></title>
      <url>%2F2017%2F03%2F21%2F%E9%92%88%E5%AF%B9github%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4hexo%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[针对github权限导致hexo部署失败的解决方案hexo deplay出错，没有反应 今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程 1.因为没有报错信息，所以直接在网上搜解决方案，集广大网友们的智慧，然后使用了npm install hexo-deployer-git –save，而后hexo deploy，但是没有解决问题，而且爆出警告： 12npm WARN optional Skipping failed optional dependency /chokidar/fsevents:npm WARN notsup Not compatible with your operating system or architecture: fsevents@1.0.15 2.更新npm npm install npm -g ，更新成功 3.继续npm install hexo-deployer-git –save，hexo deploy 还是不行： 12345678910111213141516INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...fatal: Not a git repository (or any of the parent directories): .gitFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: Not a git repository (or any of the parent directories): .gitat ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)……(E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Socket.&lt;anonymous&gt; (internal/child_process.js:319:11)at emitOne (events.js:77:13)at Socket.emit (events.js:169:7)at Pipe._onclose (net.js:477:12) 4、后来灵机一动，把.deploy_git文件夹手动删除了，重新hexo deploy了一次，成功！ 问题描述：如题，hexo最后一次部署是在8月份，然后就是秋招，一直没有在hexo博客上上传新博文，等回过头打算整理几篇博客上传，发现一直部署失败，通过搜索网上前辈们的经验，我决定重新使用hexo+github pages搭建博客（顺便更新版本了），然而······并没有什么卵用······ 错误依旧如下（这已经是重复设置SSH key后的错误版本啦，与一开始的错误描述略有不同，不过都是github权限问题）： 123456789101112131415161718192021222324252627282930313233343536373839Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.at ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at ChildProcess.cp.emit (E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)FATAL Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.Error: Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.at ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at ChildProcess.cp.emit (E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) 之前的错误，有网友们有建议将deploy处设置不要使用https，而是改为SSH，如下： 1repository: https://github.com/username/username.github.io.git 修改为 1repo：git@github.com:username/username.github.io.git 修改了很多遍，以各种姿势······然而还是没有什么卵用 当然错误不是重点，重点是怎样使我们的博客可以重新部署到github上~ 当部署失败的时候，请按照以下步骤进行：（当然，在此之前，你可以选择 hexo init）教程有很多，一搜就可以，懒癌症可以点击传送门，这是一个比较全的搭建配置教程。 (1)检查是否有SSH key登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接跳到第（3）步；如果没有，则继续。 (2)新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：1$ ssh-keygen -t rsa -C "邮箱名" 然后会出现： 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/dell/.ssh/id_rsa): 直接回车就可以。然后会出现： 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 注意：输入密码的时候没有*字样的，直接输入就好。然后会出现： 1234567891011121314Your identification has been saved in /c/Users/dell/.ssh/id_rsa.Your public key has been saved in /c/Users/dell/.ssh/id_rsa.pub.The key fingerprint is:65:69:······02:4b emailname@email.comThe key's randomart image is:+--[ RSA 2048]----+| || . o . || . o o = o || . o * = o || E o + o . || . o. . . || .. |+-----------------+ 至此，密钥已经成功生成。 (3)接下来在github上添加SSH key：① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/dell/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。 ② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。 ③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。 (4)测试设置是否成功：1$ ssh -T git@github.com 有可能会出现： 123The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 或者是 123The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 这种情况下，直接 yes 回车 然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）： 12Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. (5)设置用户信息：12$ git config --global user.name &quot;用户名&quot;$ git config --global user.email &quot;你希望的邮箱名&quot; (6)然后就可以部署你的博客到github啦~12$ hexo g$ hexo d (7)更多常见hexo命令，(传送门)[http://www.tuicool.com/articles/yUreInQ]补充1：过程中也遇到一些其他问题，比如Error: Bad file number，但是总的来说，按照上面的步骤就可以解决因为github权限问题hexo部署失败的问题（前提是你的配置文件的内容没有问题）。 补充2：windows系统不要使用它自己的命令窗口！！！使用git shell或者 git bash 等之类的一些工具。 欢迎评论交流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态加载javascript和css]]></title>
      <url>%2F2017%2F03%2F20%2FloadJsCssLater%2F</url>
      <content type="text"><![CDATA[动态加载javascript 和 css 动态加载javascript方法 1234567891011function loadScript(url) &#123; var script =document.createElement("script"); script.type="text/javascript"; script.src=url; document.body.appenfChild(script);&#125;;loadScript("javascript/lib/cookie.js"); 方法二： 123456789101112131415161718function loadScriptString(code)&#123; var script=document.createElement("script"); script.type="text/javascript"; try&#123; // firefox/safari/chrome/opera script.appendChild(document.createTextNode(code)); &#125;catch&#123; // IE早起的浏览器，需要使用script的text属性来指定javascript代码 script.text = code; &#125;; document.body.appendChild(script);&#125;;var text="function test()&#123;alert('test');&#125;";loadScriptString(text);test(); 动态加载css 方法一 12345678function loadStyles(url)&#123; var link = document.createElement(link); link.type="text/css"; link.rel="stylesheet"; link.href=url; document.getElementsByTagName("head")[0].appendChild(link);&#125;;loadStyles("css/secondindex.css"); 方法二 12345678910111213141516171819function loadStyleString(cssText)&#123; var style=document.creatElement("style"); style.type="text/css";try&#123; // firefox/safari/chrome/opera style/appendChild(document.createTextNode(cssText));&#125;catch&#123; // IE早起的浏览器，需要使用style元素的stylesheet属性的cssText属性 style.stylesheet.cssText = cssText;&#125;;document.getElementsByTagName("head")[0].appendChild(style);&#125;var css = "body&#123;color:blue;&#125;";loadStyleString(css);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript问题汇总]]></title>
      <url>%2F2017%2F03%2F20%2FJS-Issue%2F</url>
      <content type="text"><![CDATA[https 协议下安卓端默认不加载http协议请求 解决办法 https://segmentfault.com/q/1010000004727822 我的解决办法是（把图片的域名更整体更换成https） zepto touch（最新版） 在chrome 55会tap事件会触发两次zepto issue (github zepto issue double tap)[https://github.com/madrobby/zepto/issues/1249] 最后选择用 @MarvinXu 的方法移除所有pointer事件，成功解决，tap在chrome上触发两次的问题。 zepto 获取input checkbox 是否选中 获取不到 需要引入zepto的selector.js模块 【错误处理】:Uncaught SyntaxError: Invalid or unexpected token这个错误是因为，js代码中存在非英文标点符号（仔细检查下代码） 未完待续…..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
