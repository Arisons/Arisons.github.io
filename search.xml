<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Javascript正则表达式学习和总结]]></title>
      <url>%2F2017%2F03%2F23%2FJavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[新建正则表达式 方法一：直接量语法 12var reg=/pattern/attribute 创建RegExp对象的语法 1var reg =new RegExp(pattern,attributes); 参数说明： 参数 pattern 是一个字符串，指定了正则表达式的魔石或其他正则表达式 参数 attributes 是一个可选的字符串，包含属性 ‘g’、’i’和’m’，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则省略改参数。 两者的区别在于： 采用直接量语法新建的正则表达式对象在代码编辑时就会产生，是平常开发模式中常用的方式； 采用构造函数生成的正则对象要在代码运行时生成 正则表达式使用： 正则对象的方法是指这样使用的： RegExp对象.方法（字符串） 字符串对象的方法是这样使用： 字符串。方法（RegExp对象） 正则对象的属性和方法属性 gnoreCase 返回布尔值，表示RegExp对象是否具有标志 i global 返回布尔值，表示RegExp对象是否具有表示 g multiline 返回布尔值，表示RegExp对象是否具有表示 m lastIndex 一个整数，标识开始下一次匹配的字符位置 soure 返回正则表达式的原文本 （不包括反斜杠） i 执行对大小写不敏感的匹配 g 执行全局匹配 （查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配正则表达式作用 验证 由于验证时，通常需要在前后加上 ^ 和 $,以匹配整个待验证字符串； 搜索替换 搜索、替换时是否加上此限定规则更具有搜索的需求而定，此外，也有可能在前后加上 \b 而不是 ^ 和 $ 字符类匹配 […]查找方括号之间的任何字符 [^..]查找任何不在方括号之间的字符 [a-z]查找任何从小写a到小写z的字符 [A-Z]查找任何从大写A到大写Z的字符 [A-z]查找任何从大写A到小写z的字符 . 查找单个字符，除了换行和行结束符 \w 查找单词字符，等价于 [a-zA-Z0-9] \W 查找非单词字符，等价于 [^a-zA-Z0-9] \s 查找空白字符 \S 查找非空白字符 \d 查找数字，等价于[0-9] \D 查找非数字字符，等价于[^0-9] \b 匹配单词边界 \r 查找回车符 \t 查找制表符 \0 查找NULL字符 \n 查找换行符 重复字符匹配 {n,m}匹配前一项至少n次，但不能超过m次 {n,}匹配前一项n次或更多次 {n}匹配前一项n次 n?匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1} n+匹配前一项一次或多次，等价于{1,} n*匹配前一项0次或多次，等价于{0，} n$匹配任何结尾为n的字符串 ^n匹配任何开头为n的字符串 ？=n匹配任何其后紧接指定字符串n的字符串 ?!n匹配任何其后没有紧接指定字符串n的字符串 匹配特定数字 ^[1-9]\d*$ 匹配正整数 ^-[1-9]\d*$ 匹配负整数 ^-?[0-9]\d*$ 匹配整数 ^[1-9]\d*|0$ 匹配非负整数（正整数 + 0） ^-[1-9]\d*|0$ 匹配非正整数（负整数 + 0） ^[1-9]\d.\d|0.\d[1-9]\d$ 匹配正浮点数 ^-([1-9]\d.\d|0.\d[1-9]\d)$ 匹配负浮点数 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 匹配浮点数 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 匹配非负浮点数（正浮点数 + 0） ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 匹配非正浮点数（负浮点数 + 0）#####匹配特定字符串 ^[A-Za-z]+$ 匹配由26个英文字母组成的字符串 ^[A-Z]+$ 匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ 匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ 匹配由数字和26个英文字母组成的字符串 ^\w+$ 匹配由数字、26个英文字母或者下划线组成的字符串 方法test方法 检索字符串中指定的值。返回true或者false 如果字符串string中含有与RegExpObject匹配的文本，则返回true，否则返回falsedemo1 如果正则表达式带有g修饰符，则每一次test方法都从上一次匹配结束的位置开始匹配。 使用了g修饰符的正则表达式，表示要记录每一次搜索的位置，直接使用test方法，每次开始搜索的位置都是上一次匹配的最后一个位置。 1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;test方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var reg = /abc/g; var str = "123abc456abc"; console.log(reg.lastIndex);//0 console.log(reg.test(str));//true console.log(reg.lastIndex);//6 console.log(reg.test(str));//true console.log(reg.lastIndex);//12 console.log(reg.test(str));//false &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; demo2 如果正则表达式使一个空字符串，则会匹配所有的字符串，但需要使用new RegExp()方式 123456789101112131415&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;test方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; console.log(new RegExp('').test('abc'));//true console.log(/''/.test('abc'));//false console.log(/''/.test("''"));//true &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; exec方法 exec() 方法用于检索字符串中的正则表达式的匹配 返回一个数组，其中存放匹配的结果。如果未找到，则返回值为null demo112345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;exec方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "xyz"; var reg1 = /x/; var reg2 = /a/; var res1 = reg1.exec(str); var res2 = reg2.exec(str); console.log(res1);//["x", index: 0, input: "xyz"] console.log(res2);//null &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Demo2 如果正则表达式包括圆括号，则返回的数组会包括多个元素。首先是整个匹配成功的结果，后面是圆括号匹配的结果，如果有多个圆括号，他们的匹配成功结果都会成为数组元素 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;exec方法2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = 'abcdabc'; var reg = /(a)b(c)/; var res = reg.exec(str); console.log(res);//["abc", "a", "c", index: 0, input: "abcdabc"] &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 对于调用exec方法返回的数组具有以下两个属性 input 整个原待匹配的字符串 index 整个魔石匹配成功的开始位置 支持正则表达式的String对象的方法search方法 search方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的字符串。 返回值： stringObject中第一个与regexp相匹配的子串的起始位置 注释： 如果没有找到任何匹配的子串，则返回 -1（和indexOf方法类似） search() 方法不执行全局匹配，它将忽略标志g。它同时忽略regexp 的 lastIndex属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 Demo1234567891011121314&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;search方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "abcdcef"; console.log(str.search(/c/g));//2 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; match 方法 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。改方法类似indexOf()和lastIndexOf()，凡是它返回指定的值，而不是字符串的位置。 字符串对象的match方法与正则对象的exec方法比较类似 但是如果正则表达式带有g修饰符，那么match方法与exec方法就有差别 可以看到match返回了所有成功匹配的结果，但是exec方法只返回了一个Demo 12345678910111213141516171819202122&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;match方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "abcd"; var reg1 = /a/; var reg2 = /x/; console.log(str.match(reg1));//["a", index: 0, input: "abcd"] console.log(str.match(reg2));//null var str = "abcdabc"; var reg = /a/g; console.log(str.match(reg));//["a", "a"] console.log(reg.exec(str));//["a", index: 0, input: "abcdabc"] &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; replace 方法 replace() 方法用于在字符串中用一些替换另一些字符，或者换一个与正则表达式匹配的子串 返回值：一个新的字符串，使用replacement替换regexp的第一次匹配或所有匹配之后得到的 字符串stringObject 的 replace() 方法执行的查找替换的操作。它将在stringObject中查找与regexp相匹配的子字符串，然后用replacement来替换这些子串。如果regexp具有全局标志g，那么replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;replace方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "xxx"; console.log(str.replace('x','y'));//yxx console.log(str.replace(/x/,'y'));//yxx console.log(str.replace(/x/g,'y'));//yyy &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; repalce方法中特殊字符替换 字符 替换文本 $1、$2、…、$99 与regexp中的第1到99个子表达式相匹配的文本 $&amp; 位于匹配子串左侧的文本 $` 位于匹配子串左侧的文本 $` 位于匹配子串右侧的文本 $$ 直接量符号 demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;replace中的特殊字符替换&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //用子表达式替换：$1和$2 //正则表达式中()就是一个子表达式，$1对应是第一个表达式的内容，即java，$2为script var str = "javascript"; console.log(str.replace(/(java)(script)/,'$2$1')); //输出：scriptjava //$&amp; 为正则表达式匹配的字符串 //正则表达式通过直接量java来匹配，匹配结果为java，则 $&amp;的值为java，然后用字符串$&amp;-来替换匹配的字符串 var str1 = "javascript"; console.log(str1.replace(/java/,'$&amp;-')); //输出：java-script var str2 = "javascript"; // $`为匹配子串ava的左侧文本，则为j console.log(str2.replace(/ava/,"$`")); //输出：jjscript // $'为匹配子串ava的右侧文本，则为script console.log(str2.replace(/ava/,"$'")); //输出：jscriptscript // $$为直接量符号，即插入一个$符号 console.log(str2.replace(/ava/,"$$"));//输出：j$script &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;replace的参数replacement是函数match为匹配整个字符串，即：xyz456789%$&amp;^a1 为第一个子表达式，([^\d]*),匹配0个或多个非数字的字符，即：xyza2 为第二个子表达式， (\d*),匹配0个或多个的数字，即：45678a3 为第三个子表达式， ([^\w]*),匹配0个或匹配任何非单词字符。等价于[^A-Za-z0-9_],即%$&amp;^index 为魔石匹配出现的位置，从第一个字符已经匹配成功，则位置为0string为字符串本身，即： xyz45678%$&amp;^ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;replace的参数replacement是函数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; function replacer(match, a1, a2, a3, index, string) &#123; return [a1, a2, a3].join(' ~ '); &#125; var str = 'xyz45678%$&amp;^'; var reg = /([^\d]*)(\d*)([^\w]*)/ var res = str.replace(reg, replacer); console.log(res);//xyz ~ 45678 ~ %$&amp;^ &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; * split方法 split（‘字符串的分割正则’，返回数组的最大成员数）；返回分割后各部分组成的数组 demo12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;split方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = 'a,b , c,d'; var res = str.split(",");//以逗号来分割字符串 console.log(res);//["a", "b ", " c", "d"]; var str1 = 'a,b , c,,d'; var res1 = str1.split(/,*/);//以0或多个逗号来分割字符串 console.log(res1);//["a", "b", " ", " ", "c", "d"]; var str2 = 'a, b,c, d'; var res2 = str2.split(/, */);//以0或对个逗号空格来分割字符串 console.log(res2);//["a", "b", "c", "d"]; var str3 = 'a, b,c, d'; var res3 = str3.split(/, */,2);//以0或对个逗号空格来分割字符串，同时限制返回数组中最多有两项 console.log(res3);//["a", "b"]; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以变换正则的匹配规则来分割字符串 下面真这个的匹配规则是以0或多个X来进行分割，如果加上括号则括号匹配的部分也就是分割规则也会成为数组成员返回 demo123456789101112131415161718&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;split方法2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = "x@@xx@xx@@"; var res = str.split(/x*/);//以0或者对个x为分隔符 console.log(res);//["", "@", "@", "@", "@", "@"]; var res1 = str.split(/(x*)/);//如果加上括号则括号匹配的部分也就是分割规则也会作为数组成员返回 console.log(res1);//["", "x", "@", "", "@", "xx", "@", "xx", "@", "", "@"] &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 正则表达式的一些应用* 1、字符串中出现最多的字符 var re = /(\w)/1+/g; (\w) 外面的圆括号表示分组，\1表示重复第一分组的内容， \1+表示\w匹配到的字符重复n次，后面的g表示执行全部替换 str.replace的第二个参数是函数，参数a表示真个匹配到的字符串，b表示第一捕获分组也就是出现重复的单个字符，将啊。length与记录过的最多重复num比较，如果a.length更大，就将它赋值给num，用value记录重复字符b，这个函数返回的是替换文本，但这里没有返回值，也就是说替换为空，每次替换这个函数都被执行 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;字符串中出现次数最多的字符&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var str = 'mmmmmmmmaaammmmmmmmmbbbbsccc'; function most(str) &#123; var arr = str.split(''); str = arr.sort().join('');//将字符串按单个字符分割，然后排序组合，经过这一步，相同的字符就会排列到一起 var reg = /(\w)\1+/g; var num = 0; var value = ''; str.replace(reg, function (a,b) &#123; // console.log(a); if (num&lt;a.length) &#123; num = a.length; value = b; &#125; &#125;); return '出现次数最多的字符是' + value + '出现了' + num + '次'; &#125; console.log(most(str)); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 从url中提取子域名12345var url = "http://www.abc.com"; var reg = /[^.]+/;//匹配除了.之外的其他字符 var res = reg.exec(url)[0].substr(7); console.log(reg.exec(url));//["http://www", index: 0, input: "http://www.abc.com"] console.log(res);//www 常用的正则表达式 匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7} 匹配QQ号码：[1-9][0-9]{4,} 邮政编码：[1-9]\d5 身份证： /^(\d{14}|\d{17})(\d|[xX])$/ 匹配ip地址：\d+.\d+.\d+.\d+ 匹配账号是否合法（字母开头，允许5-16字节，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$表单验证时很实用 匹配中文字符： /[\u4E00-\u9FA5\uf900-ufasd]/ 匹配Email地址：/^([a-zA-Z_0-9-])+@([a-zA-Z_0-9-])+(.[a-zA-Z_0-9-])+$/ （邮箱由三部分组成：1、一个或多个字母数字下划线和杠+@+一个或多个字母数字下划线和杠+。+一个或多个字母数字下划线和杠） 匹配网址url： [a-zA-z]+://[^\s]* 判断字符串是不是由数字组成： /^\d*$/ 限制文本框只能输入数字和小数点（两位小数点）：/^\d*.?\d{0,2}$/（说明：开头有0个或多个数字，（?表示匹配前一项0次或多次）中间有0个或者1个小数点，小数点后面有0个或者最多2个数字） 用户名正则： /^[\u4e00-\u9FA5\uf900-ufa2d-\ufa2d\w]{4,16}$/ (匹配规则：只能是中文，英文，数字，下划线，4-16个字符；匹配中文规则：/[\u4E00-\u9FA5\uf900-\ufa2d]/ ， \w 是匹配英文，数字，下划线)+匹配英文地址：/^[a-zA-Z][.a-zA-Z\s,0-9]?[a-zA-Z]+ （/匹&gt; &gt; + 配规则：包含点，字母，逗号，数字，但是开头和结尾必须是字母；分析开头必须为字母可以这样写/[a-zA-Z]/）结尾必须是字母可以这样写：/[a-zA-Z]+/ 中间包含点，字母，空格，逗号，数字的正则：/[a-zA-Z\s,0-9]?/ 外面的*号是0个或者多个，后面的问号？代表可有可无，有就匹配，没有就不匹配 匹配价格： /^\d*(.\d{0,2})?$/ (匹配价格： 开头有0或者多个数字，中间可能有一个小数点，后面有可能有0-2位小数) 单词的首字母大写：/\b(\w)|\s(\w)/g 验证日期格式： /^\d{4}[-/]\d{1,2}[-/]\d{1,2}$/ (日起格式&gt; + 有两种yyyy-mm-dd或yyyy/mm/dd 分析：月份和天数可能有一位或两位) 断断续续敲了这么多，感觉还是晕晕的。（实际项目中，会用到的基本就是验证用户名手机号邮箱，获取地址栏地址参数…敲完开饭）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-Next底部powered&&logo栏更改以及注意事项]]></title>
      <url>%2F2017%2F03%2F23%2FHexo-Next%E5%BA%95%E9%83%A8powered-logo%E6%A0%8F%E6%9B%B4%E6%94%B9%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[Hexo-Next底部logo栏更改以及注意事项（附官方文档）研究了hexo，搭建博客很方便，主题，插件化功能非常强大。 本篇文章适合对象：各位用的是Next主题，那么适合看本篇文章，如果别的主题想找思路的适合看看练练手。想学习基础更改，优化，简单配置请看 点击官方文档。这里面有基础的教程以及第三方能用到的插件都有介绍，都是傻瓜式操作。 PS:做插件化的朋友，请注意，站内搜索swiftype只有老用户才免费，新用户只有14天之后收费，RMB玩家可以略过，其他小伙伴可以选择Local Search，本站右上角就是Local Search，精准度还可以没有swiftype准，用用再说。搭建LocalSearch 方法如下： 如果有其他好的插件和优化方法，我更新本片博文，当然大家有好点，好工具也希望邮件私信我，一同来分享，帮助大家打造富有个性化的博客。问题说明用Next主题搭建起来的博客，在底部会有一个特别烦人的官方logo 对于强迫症的我必须要改掉、改掉、改掉！查遍了所有文章都没有告诉，遂打算自己写一篇，有需要的可以看看。（含泪阅读了Next所有的源文件，最后不过是两句话能说明白。。却耗费我3,4个小时，让我多说一会废话凑凑字数吧，都是眼泪啊！） 成果展示 看起来至少比原来的好多了，更有个性化风格。 解决方案重点来啦。 1.首先，找到 \themes\next\layout_partials\下面的footer.swig文件，打开会发现，如下图的语句： 看到划框的地方了吗？ 第一个框 是下面侧栏的“日期❤ XXX”如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把…标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将..都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 2.接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\ 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）打开之后，如图： 看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 到此就可以pu上去了，等待2分钟就搞定了。有的时候可能有延迟。快去改掉那些不属于你的元素吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apply 和 call 的区别]]></title>
      <url>%2F2017%2F03%2F22%2Fapply%E5%92%8Ccall%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[apply 和 call 的区别ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。 apply( )apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。 12345678910var obj = &#123; name : &apos;linxin&apos;&#125;function func(firstName, lastName)&#123; console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);&#125;func.apply(obj, [&apos;A&apos;, &apos;B&apos;]); // A linxin B 可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。 call( )call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。 123456789var obj = &#123; name: 'linxin'&#125;function func(firstName, lastName) &#123; console.log(firstName + ' ' + this.name + ' ' + lastName);&#125;func.call(obj, 'C', 'D'); // C linxin D 对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。 对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。 apply 和 call 的用法1.改变 this 指向 123456789var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this.name);&#125;func.call(obj); // linxin 我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于 123function func() &#123; console.log(obj.name);&#125; 2.借用别的对象的方法先看例子 1234567891011var Person1 = function () &#123; this.name = 'linxin';&#125;var Person2 = function () &#123; this.getname = function () &#123; console.log(this.name); &#125; Person1.call(this);&#125;var person = new Person2();person.getname(); // linxin 从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。 3.调用函数apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数。 1234function func() &#123; console.log('linxin');&#125;func.call(); // linxin call 和 bind 的区别在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容。它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。它们之间的区别有以下两点。 1.bind 发返回值是函数 12345678910var obj = &#123; name: 'linxin'&#125;function func() &#123; console.log(this.name);&#125;var func1 = func.bind(obj);func1(); // linxin bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。 2.参数的使用 123456789function func(a, b, c) &#123; console.log(a, b, c);&#125;var func1 = func.bind(null,'linxin');func('A', 'B', 'C'); // A B Cfunc1('A', 'B', 'C'); // linxin A Bfunc1('B', 'C'); // linxin B Cfunc.call(null, 'linxin'); // linxin undefined undefined call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。 在低版本浏览器没有 bind 方法，我们也可以自己实现一个。 12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex布局语法教程]]></title>
      <url>%2F2017%2F03%2F22%2FFlex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[网页布局（layout）是css的一个中带你应用 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 ###三、容器的属性以下6个属性设置在容器上。 123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。（1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 12345678flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性123456orderflex-growflex-shrinkflex-basisflexalign-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[针对github权限导致hexo部署失败的解决方案]]></title>
      <url>%2F2017%2F03%2F21%2F%E9%92%88%E5%AF%B9github%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4hexo%E9%83%A8%E7%BD%B2%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[针对github权限导致hexo部署失败的解决方案hexo deplay出错，没有反应 今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程 1.因为没有报错信息，所以直接在网上搜解决方案，集广大网友们的智慧，然后使用了npm install hexo-deployer-git –save，而后hexo deploy，但是没有解决问题，而且爆出警告： 12npm WARN optional Skipping failed optional dependency /chokidar/fsevents:npm WARN notsup Not compatible with your operating system or architecture: fsevents@1.0.15 2.更新npm npm install npm -g ，更新成功 3.继续npm install hexo-deployer-git –save，hexo deploy 还是不行： 12345678910111213141516INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...fatal: Not a git repository (or any of the parent directories): .gitFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: Not a git repository (or any of the parent directories): .gitat ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)……(E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Socket.&lt;anonymous&gt; (internal/child_process.js:319:11)at emitOne (events.js:77:13)at Socket.emit (events.js:169:7)at Pipe._onclose (net.js:477:12) 4、后来灵机一动，把.deploy_git文件夹手动删除了，重新hexo deploy了一次，成功！ 问题描述：如题，hexo最后一次部署是在8月份，然后就是秋招，一直没有在hexo博客上上传新博文，等回过头打算整理几篇博客上传，发现一直部署失败，通过搜索网上前辈们的经验，我决定重新使用hexo+github pages搭建博客（顺便更新版本了），然而······并没有什么卵用······ 错误依旧如下（这已经是重复设置SSH key后的错误版本啦，与一开始的错误描述略有不同，不过都是github权限问题）： 123456789101112131415161718192021222324252627282930313233343536373839Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.at ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at ChildProcess.cp.emit (E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5)FATAL Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.Error: Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.at ChildProcess.&lt;anonymous&gt; (E:\blog\HexoBlog\node_modules\hexo-util\lib\spawn.js:37:17)at emitTwo (events.js:87:13)at ChildProcess.emit (events.js:172:7)at ChildProcess.cp.emit (E:\blog\HexoBlog\node_modules\cross-spawn\lib\enoent.js:40:29)at maybeClose (internal/child_process.js:827:16)at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) 之前的错误，有网友们有建议将deploy处设置不要使用https，而是改为SSH，如下： 1repository: https://github.com/username/username.github.io.git 修改为 1repo：git@github.com:username/username.github.io.git 修改了很多遍，以各种姿势······然而还是没有什么卵用 当然错误不是重点，重点是怎样使我们的博客可以重新部署到github上~ 当部署失败的时候，请按照以下步骤进行：（当然，在此之前，你可以选择 hexo init）教程有很多，一搜就可以，懒癌症可以点击传送门，这是一个比较全的搭建配置教程。 (1)检查是否有SSH key登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接跳到第（3）步；如果没有，则继续。 (2)新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写：1$ ssh-keygen -t rsa -C "邮箱名" 然后会出现： 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/dell/.ssh/id_rsa): 直接回车就可以。然后会出现： 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 注意：输入密码的时候没有*字样的，直接输入就好。然后会出现： 1234567891011121314Your identification has been saved in /c/Users/dell/.ssh/id_rsa.Your public key has been saved in /c/Users/dell/.ssh/id_rsa.pub.The key fingerprint is:65:69:······02:4b emailname@email.comThe key's randomart image is:+--[ RSA 2048]----+| || . o . || . o o = o || . o * = o || E o + o . || . o. . . || .. |+-----------------+ 至此，密钥已经成功生成。 (3)接下来在github上添加SSH key：① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/dell/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。 ② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。 ③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。 (4)测试设置是否成功：1$ ssh -T git@github.com 有可能会出现： 123The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 或者是 123The authenticity of host 'github.com (192.30.252.1)' can't be established.RSA key fingerprint is nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? 这种情况下，直接 yes 回车 然后会出现（也可能在 ++$ ssh -T git@github.com++ 之后，直接出现的就是这个，我就是这样~）： 12Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. (5)设置用户信息：12$ git config --global user.name &quot;用户名&quot;$ git config --global user.email &quot;你希望的邮箱名&quot; (6)然后就可以部署你的博客到github啦~12$ hexo g$ hexo d (7)更多常见hexo命令，(传送门)[http://www.tuicool.com/articles/yUreInQ]补充1：过程中也遇到一些其他问题，比如Error: Bad file number，但是总的来说，按照上面的步骤就可以解决因为github权限问题hexo部署失败的问题（前提是你的配置文件的内容没有问题）。 补充2：windows系统不要使用它自己的命令窗口！！！使用git shell或者 git bash 等之类的一些工具。 欢迎评论交流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态加载javascript和css]]></title>
      <url>%2F2017%2F03%2F20%2FloadJsCssLater%2F</url>
      <content type="text"><![CDATA[动态加载javascript 和 css 动态加载javascript方法 1234567891011function loadScript(url) &#123; var script =document.createElement("script"); script.type="text/javascript"; script.src=url; document.body.appenfChild(script);&#125;;loadScript("javascript/lib/cookie.js"); 方法二： 123456789101112131415161718function loadScriptString(code)&#123; var script=document.createElement("script"); script.type="text/javascript"; try&#123; // firefox/safari/chrome/opera script.appendChild(document.createTextNode(code)); &#125;catch&#123; // IE早起的浏览器，需要使用script的text属性来指定javascript代码 script.text = code; &#125;; document.body.appendChild(script);&#125;;var text="function test()&#123;alert('test');&#125;";loadScriptString(text);test(); 动态加载css 方法一 12345678function loadStyles(url)&#123; var link = document.createElement(link); link.type="text/css"; link.rel="stylesheet"; link.href=url; document.getElementsByTagName("head")[0].appendChild(link);&#125;;loadStyles("css/secondindex.css"); 方法二 12345678910111213141516171819function loadStyleString(cssText)&#123; var style=document.creatElement("style"); style.type="text/css";try&#123; // firefox/safari/chrome/opera style/appendChild(document.createTextNode(cssText));&#125;catch&#123; // IE早起的浏览器，需要使用style元素的stylesheet属性的cssText属性 style.stylesheet.cssText = cssText;&#125;;document.getElementsByTagName("head")[0].appendChild(style);&#125;var css = "body&#123;color:blue;&#125;";loadStyleString(css);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript问题汇总]]></title>
      <url>%2F2017%2F03%2F20%2FJS-Issue%2F</url>
      <content type="text"><![CDATA[https 协议下安卓端默认不加载http协议请求 解决办法 https://segmentfault.com/q/1010000004727822 我的解决办法是（把图片的域名更整体更换成https） zepto touch（最新版） 在chrome 55会tap事件会触发两次zepto issue (github zepto issue double tap)[https://github.com/madrobby/zepto/issues/1249] 最后选择用 @MarvinXu 的方法移除所有pointer事件，成功解决，tap在chrome上触发两次的问题。 zepto 获取input checkbox 是否选中 获取不到 需要引入zepto的selector.js模块 【错误处理】:Uncaught SyntaxError: Invalid or unexpected token这个错误是因为，js代码中存在非英文标点符号（仔细检查下代码） 未完待续…..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
